#!/bin/bash

# Multi-Claude-Code (mcc) - Manage parallel Claude development tasks with git worktrees
# Version: 1.0.0

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Configuration
MCC_DIR=".mcc"
WORKTREE_PREFIX="work/"
CLAUDE_CMD="claude-code"

# Helper functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

log_task() {
    echo -e "${PURPLE}[TASK]${NC} $1"
}

# Check if we're in a git repository
check_git_repo() {
    if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
        log_error "Not in a git repository. Please run 'git init' first."
        exit 1
    fi
}

# Initialize MCC structure
init_mcc() {
    if [[ ! -d "$MCC_DIR" ]]; then
        mkdir -p "$MCC_DIR"
        log_info "Created $MCC_DIR directory"
    fi
    
    if [[ ! -f "$MCC_DIR/active_tasks.txt" ]]; then
        touch "$MCC_DIR/active_tasks.txt"
        log_info "Created active tasks tracking file"
    fi
}

# Get the main branch name
get_main_branch() {
    # Try to get default branch from origin first
    if git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@'; then
        return
    fi
    
    # Fallback to current branch if it's main/master
    local current_branch
    current_branch=$(git branch --show-current)
    if [[ "$current_branch" == "main" || "$current_branch" == "master" ]]; then
        echo "$current_branch"
        return
    fi
    
    # Check if main or master branches exist
    if git show-ref --verify --quiet refs/heads/main; then
        echo "main"
    elif git show-ref --verify --quiet refs/heads/master; then
        echo "master"
    else
        echo "main"  # Default fallback
    fi
}

# Generate unique branch name
generate_branch_name() {
    local task_name="$1"
    local branch_name="${WORKTREE_PREFIX}${task_name}"
    local counter=1
    
    while git show-ref --verify --quiet "refs/heads/$branch_name" 2>/dev/null; do
        branch_name="${WORKTREE_PREFIX}${task_name}-${counter}"
        ((counter++))
    done
    
    echo "$branch_name"
}

# Create new worktree and launch Claude
new_task() {
    local task_name="$1"
    
    if [[ -z "$task_name" ]]; then
        log_error "Task name is required"
        echo "Usage: mcc new <task-name>"
        exit 1
    fi
    
    check_git_repo
    init_mcc
    
    local branch_name
    branch_name=$(generate_branch_name "$task_name")
    local worktree_dir="../${task_name}-worktree"
    local main_branch
    main_branch=$(get_main_branch)
    
    # Check if worktree directory already exists
    if [[ -d "$worktree_dir" ]]; then
        log_error "Worktree directory $worktree_dir already exists"
        exit 1
    fi
    
    log_info "Creating worktree for task: $task_name"
    log_info "Branch: $branch_name"
    log_info "Directory: $worktree_dir"
    
    # Create worktree
    if ! git worktree add -b "$branch_name" "$worktree_dir" "$main_branch"; then
        log_error "Failed to create worktree"
        exit 1
    fi
    
    # Create task file in worktree
    local task_file="$worktree_dir/TASK.md"
    cat > "$task_file" << EOF
# Task: $task_name

**Branch:** $branch_name  
**Created:** $(date)  
**Status:** In Progress  

## Description
<!-- Describe what this task involves -->

## Progress
- [ ] Initial setup
- [ ] Implementation
- [ ] Testing
- [ ] Documentation

## Notes
<!-- Add notes, decisions, and context here -->

## Handoff Information
<!-- Information for the next Claude or developer -->

EOF
    
    # Add task to active tasks
    echo "$task_name|$branch_name|$worktree_dir|$(date '+%Y-%m-%d %H:%M:%S')" >> "$MCC_DIR/active_tasks.txt"
    
    # Open new Terminal window with Claude Code
    local abs_worktree_dir
    abs_worktree_dir=$(cd "$worktree_dir" && pwd)
    
    # For testing, we'll simulate the Terminal launch
    if [[ "${MCC_TEST_MODE:-}" == "1" ]]; then
        log_info "TEST MODE: Would launch Terminal with command:"
        log_info "cd '$abs_worktree_dir' && $CLAUDE_CMD"
    else
        osascript << EOF
tell application "Terminal"
    do script "cd '$abs_worktree_dir' && echo 'Starting Claude Code for task: $task_name' && echo 'Branch: $branch_name' && echo 'Worktree: $abs_worktree_dir' && echo '' && $CLAUDE_CMD"
    set custom title of front window to "Claude: $task_name"
end tell
EOF
    fi
    
    log_success "Created task '$task_name' in branch '$branch_name'"
    log_info "Opening Terminal window with Claude Code..."
    log_info "Task file created at: $task_file"
}

# List active tasks
list_tasks() {
    check_git_repo
    init_mcc
    
    if [[ ! -s "$MCC_DIR/active_tasks.txt" ]]; then
        log_info "No active tasks"
        return 0
    fi
    
    echo -e "${CYAN}Active Tasks:${NC}"
    echo "============"
    
    while IFS='|' read -r task_name branch_name worktree_dir created_date; do
        if [[ -d "$worktree_dir" ]]; then
            local status_icon="🟢"
            local status="Active"
            
            # Check if there are uncommitted changes
            if (cd "$worktree_dir" && git status --porcelain | grep -q .); then
                status_icon="🟡"
                status="Working"
            fi
            
            # Check if there are unpushed commits
            if (cd "$worktree_dir" && git log --oneline "@{u}.." 2>/dev/null | grep -q .); then
                status_icon="🔵"
                status="Ready"
            fi
            
            echo -e "${status_icon} ${PURPLE}$task_name${NC}"
            echo -e "   Branch: $branch_name"
            echo -e "   Path: $worktree_dir"
            echo -e "   Status: $status"
            echo -e "   Created: $created_date"
            echo ""
        fi
    done < "$MCC_DIR/active_tasks.txt"
}

# Show detailed status
show_status() {
    check_git_repo
    init_mcc
    
    echo -e "${CYAN}Multi-Claude-Code Status${NC}"
    echo "======================="
    echo ""
    
    # Show current branch
    local current_branch
    current_branch=$(git branch --show-current)
    echo -e "Current branch: ${GREEN}$current_branch${NC}"
    echo ""
    
    # List worktrees
    echo -e "${CYAN}Git Worktrees:${NC}"
    git worktree list --porcelain | while IFS= read -r line; do
        if [[ $line == worktree* ]]; then
            local worktree_path=${line#worktree }
            echo -e "  📁 $worktree_path"
        elif [[ $line == branch* ]]; then
            local branch_name=${line#branch }
            echo -e "     Branch: ${GREEN}$branch_name${NC}"
        fi
    done
    echo ""
    
    # Show active tasks
    list_tasks
}

# Complete a task and merge back
done_task() {
    local task_name="$1"
    
    if [[ -z "$task_name" ]]; then
        log_error "Task name is required"
        echo "Usage: mcc done <task-name>"
        exit 1
    fi
    
    check_git_repo
    init_mcc
    
    # Find task in active tasks
    local task_line
    local branch_name
    local worktree_dir
    
    if ! task_line=$(grep "^$task_name|" "$MCC_DIR/active_tasks.txt"); then
        log_error "Task '$task_name' not found in active tasks"
        exit 1
    fi
    
    IFS='|' read -r _ branch_name worktree_dir _ <<< "$task_line"
    
    if [[ ! -d "$worktree_dir" ]]; then
        log_error "Worktree directory $worktree_dir not found"
        exit 1
    fi
    
    log_info "Completing task: $task_name"
    log_info "Branch: $branch_name"
    
    # Check for uncommitted changes
    if (cd "$worktree_dir" && git status --porcelain | grep -q .); then
        log_warning "Uncommitted changes found in worktree"
        echo "Please commit your changes first, then run 'mcc done $task_name' again"
        echo ""
        echo "To commit changes:"
        echo "  cd $worktree_dir"
        echo "  git add ."
        echo "  git commit -m 'Complete $task_name'"
        exit 1
    fi
    
    # Switch to main branch
    local main_branch
    main_branch=$(get_main_branch)
    git checkout "$main_branch"
    
    # Pull latest changes
    if git remote | grep -q origin; then
        log_info "Pulling latest changes from origin/$main_branch"
        git pull origin "$main_branch" || true
    fi
    
    # Merge the feature branch
    log_info "Merging $branch_name into $main_branch"
    if git merge --no-ff "$branch_name" -m "Merge task: $task_name

Completed work from branch $branch_name
Worktree: $worktree_dir"; then
        log_success "Successfully merged task '$task_name'"
    else
        log_error "Merge failed. Please resolve conflicts manually"
        exit 1
    fi
    
    # Clean up worktree
    log_info "Cleaning up worktree..."
    git worktree remove "$worktree_dir" --force
    
    # Delete the feature branch
    git branch -d "$branch_name"
    
    # Remove from active tasks
    grep -v "^$task_name|" "$MCC_DIR/active_tasks.txt" > "$MCC_DIR/active_tasks.txt.tmp"
    mv "$MCC_DIR/active_tasks.txt.tmp" "$MCC_DIR/active_tasks.txt"
    
    log_success "Task '$task_name' completed and cleaned up"
}

# Create a handoff commit with context
handoff_task() {
    local task_name="$1"
    local message="$2"
    
    if [[ -z "$task_name" ]]; then
        log_error "Task name is required"
        echo "Usage: mcc handoff <task-name> [message]"
        exit 1
    fi
    
    check_git_repo
    init_mcc
    
    # Find task in active tasks
    local task_line
    local branch_name
    local worktree_dir
    
    if ! task_line=$(grep "^$task_name|" "$MCC_DIR/active_tasks.txt"); then
        log_error "Task '$task_name' not found in active tasks"
        exit 1
    fi
    
    IFS='|' read -r _ branch_name worktree_dir _ <<< "$task_line"
    
    if [[ ! -d "$worktree_dir" ]]; then
        log_error "Worktree directory $worktree_dir not found"
        exit 1
    fi
    
    (
        cd "$worktree_dir"
        
        # Check if there are changes to commit
        if ! git status --porcelain | grep -q .; then
            log_warning "No changes to handoff"
            exit 0
        fi
        
        # Stage all changes
        git add .
        
        # Create handoff commit
        local commit_message="🤝 Handoff: $task_name"
        if [[ -n "$message" ]]; then
            commit_message="$commit_message - $message"
        fi
        
        commit_message="$commit_message

Progress update and context handoff for task: $task_name
$(date)

Current status and next steps documented in TASK.md"
        
        git commit -m "$commit_message"
        
        log_success "Created handoff commit for task '$task_name'"
        log_info "Context saved for next Claude instance"
    )
}

# Clean up orphaned worktrees
cleanup() {
    check_git_repo
    init_mcc
    
    log_info "Cleaning up orphaned worktrees and tasks..."
    
    # Get list of actual worktrees
    local actual_worktrees
    actual_worktrees=$(git worktree list --porcelain | grep '^worktree ' | cut -d' ' -f2-)
    
    # Clean up active_tasks.txt
    local temp_file="$MCC_DIR/active_tasks.txt.tmp"
    > "$temp_file"
    
    while IFS='|' read -r task_name branch_name worktree_dir created_date; do
        if [[ -d "$worktree_dir" ]] && echo "$actual_worktrees" | grep -q "^$worktree_dir$"; then
            echo "$task_name|$branch_name|$worktree_dir|$created_date" >> "$temp_file"
        else
            log_warning "Removing orphaned task: $task_name"
        fi
    done < "$MCC_DIR/active_tasks.txt"
    
    mv "$temp_file" "$MCC_DIR/active_tasks.txt"
    
    log_success "Cleanup completed"
}

# Show help
show_help() {
    cat << EOF
Multi-Claude-Code (mcc) - Manage parallel Claude development tasks

USAGE:
    mcc <command> [arguments]

COMMANDS:
    new, n <task-name>        Create new worktree and launch Claude Code
    list, ls                  List all active tasks
    status, st                Show detailed status of all worktrees
    done, d <task-name>       Complete task, merge, and cleanup
    handoff, h <task-name> [msg]  Create handoff commit with context
    cleanup, c                Clean up orphaned worktrees
    help                      Show this help message

EXAMPLES:
    mcc new auth-system       # Start working on authentication
    mcc list                  # See all active tasks
    mcc handoff auth-system "Login flow completed"
    mcc done auth-system      # Merge and cleanup when finished
    mcc status                # Detailed overview

WORKFLOW:
    1. mcc new <task>         # Start new task
    2. Work in Claude Code    # Develop in isolation
    3. mcc handoff <task>     # Save progress/context
    4. mcc done <task>        # Complete and merge

For more information, see README.md
EOF
}

# Main command dispatcher
main() {
    case "${1:-}" in
        "new"|"n")
            new_task "$2"
            ;;
        "list"|"ls")
            list_tasks
            ;;
        "status"|"st")
            show_status
            ;;
        "done"|"d")
            done_task "$2"
            ;;
        "handoff"|"h")
            handoff_task "$2" "$3"
            ;;
        "cleanup"|"c")
            cleanup
            ;;
        "help"|"--help"|"-h"|"")
            show_help
            ;;
        *)
            log_error "Unknown command: $1"
            echo "Run 'mcc help' for usage information"
            exit 1
            ;;
    esac
}

# Run main function with all arguments
main "$@"